import "rv_base/RV32I.core_desc"
import "rv_base/RV64I.core_desc"
import "rv_base/RVM.core_desc"
import "rv_base/RVC.core_desc"
import "rv_base/RVD.core_desc"
import "rv_base/RVF.core_desc"
import "rv_base/RVP.core_desc"
import "rv_base/RVV.core_desc"
import "tum_mod.core_desc"
import "encoding.core_desc"


Core RV32IMACFDP provides riscv_encoding, RV32I, RV32IC, RV32M, RV32F, RV32FC, RV32D, RV32DC, RV32P, Zifencei, tum_csr, tum_ret, tum_rva {
    architectural_state {
        CSR[CSR_USTATUS] = 0x0000000B;
        CSR[CSR_SSTATUS] = 0x0000000B;
        // TODO: Mirror mstatus to sstatus?
        CSR[CSR_MSTATUS] = 0x0000000B;
        CSR[CSR_MSTATUS] |= MSTATUS_FS; // enable fpu

        CSR[CSR_MISA] = 0x4014112D;

        CSR[0xC10] = 0x00000003; // ?

        CSR[CSR_MIE] = 0xFFFFFBBB;
        CSR[CSR_SIE] = CSR[CSR_MIE] & (~(0x888));
        CSR[CSR_UIE] = CSR[CSR_MIE] & (~(0xAAA));

    }
}
Core RV32IMACP provides riscv_encoding, RV32I, RV32IC, RV32M, RV32P, tum_csr, tum_ret, tum_rva {
    architectural_state {
        CSR[CSR_USTATUS] = 0x0000000B;
        CSR[CSR_SSTATUS] = 0x0000000B;
        // TODO: Mirror mstatus to sstatus?
        CSR[CSR_MSTATUS] = 0x0000000B;
        CSR[CSR_MSTATUS] |= MSTATUS_FS; // enable fpu

        CSR[CSR_MISA] = 0x4014112D;

        CSR[0xC10] = 0x00000003; // ?

        CSR[CSR_MIE] = 0xFFFFFBBB;
        CSR[CSR_SIE] = CSR[CSR_MIE] & (~(0x888));
        CSR[CSR_UIE] = CSR[CSR_MIE] & (~(0xAAA));

    }
}

Core RV64IM provides RV64I, RV32M, tum_csr, tum_ret {
    architectural_state {
        CSR[CSR_USTATUS] = 0x0000000B;
        CSR[CSR_SSTATUS] = 0x0000000B;
        CSR[CSR_MSTATUS] = 0x0000000B;

        CSR[CSR_MISA] = 0x4014112D;

        CSR[0xC10] = 0x00000003; // ?

        CSR[CSR_MIE] = 0xFFFFFBBB;
        CSR[CSR_SIE] = CSR[CSR_MIE] & (~(0x888));
        CSR[CSR_UIE] = CSR[CSR_MIE] & (~(0xAAA));
    }
}
// TODO: RV64IMACFDP, RV64IMACP
